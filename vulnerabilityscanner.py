import socket
import threading
import concurrent.futures
from datetime import datetime
import sys
import queue
import ssl
import json
import logging
import time
from typing import Dict, List, Optional, Union

class VulnerabilityScanner:
    """
    Enhanced vulnerability scanner with additional security checks and improved performance.

    Attributes:
        target (str): Target IP address or hostname
        port_range (tuple): Range of ports to scan (start_port, end_port)
        thread_count (int): Number of concurrent threads
        timeout (int): Connection timeout in seconds
        verbose (bool): Enable detailed output
    """

    def __init__(self, target: str, port_range: tuple = (1, 1024),
                 thread_count: int = 100, timeout: int = 1, verbose: bool = False):
        self.target = target
        self.port_range = port_range
        self.thread_count = thread_count
        self.timeout = timeout
        self.verbose = verbose
        self.open_ports = queue.Queue()
        self.results = []
        self.scan_start_time = None
        self.scan_end_time = None

        # Setup logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            filename='vulnerability_scan.log'
        )
        self.logger = logging.getLogger(__name__)

    def validate_target(self) -> bool:
        """Validate target IP address or hostname."""
        try:
            socket.gethostbyname(self.target)
            return True
        except socket.error as e:
            self.logger.error(f"Invalid target: {e}")
            return False

    def port_scan(self, port: int) -> None:
        """
        Scan individual port and perform security checks.

        Args:
            port (int): Port number to scan
        """
        try:
            # Rate limiting to prevent overwhelming target
            time.sleep(0.1)

            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)

            result = sock.connect_ex((self.target, port))
            if result == 0:
                security_info = self.perform_security_checks(sock, port)
                self.open_ports.put(port)
                self.results.append(security_info)

                if self.verbose:
                    print(f"Port {port}: {json.dumps(security_info, indent=2)}")

            sock.close()

        except Exception as e:
            self.logger.error(f"Error scanning port {port}: {e}")

    def perform_security_checks(self, sock: socket.socket, port: int) -> Dict:
        """
        Perform comprehensive security checks on open port.

        Args:
            sock (socket.socket): Connected socket
            port (int): Port number

        Returns:
            Dict: Security check results
        """
        security_info = {
            "port": port,
            "service": self.identify_service(port),
            "banner": self.grab_banner(sock),
            "ssl_info": None,
            "vulnerabilities": []
        }

        # Check SSL/TLS if appropriate
        if port in [443, 8443]:
            security_info["ssl_info"] = self.check_ssl_security(sock)

        # Check for common vulnerabilities
        security_infonfo["vulnerabilities"] = self.check_common_vulnerabilities(port, security_info["banner"])

        return securiurity_info

    def check_ssl_security(self, sock: socket.socket) -> Dict:
        """Check SSL/TLS security configuration."""
        try:
            context = ssl.create_default_context()
            ssl_sock = context.wrap_socket(sock, server_hostname=self.target)

            return {
                "version": ssl_sock.version(),
                "cipher": ssl_sock.cipher(),
                "cert_expires": ssl_sock.getpeercert()['notAfter']
            }
        except Exception as e:
            self.logger.warning(f"SSL check failed: {e}")
            return {"error": str(e)}

    def identify_service(self, port: int) -> str:
        """Identify common services based on port number."""
        common_services = {
            20: "FTP-data", 21: "FTP", 22: "SSH", 23: "Telnet",
            25: "SMTP", 53: "DNS", 80: "HTTP", 443: "HTTPS",
            110: "POP3", 143: "IMAP", 445: "SMB", 3306: "MySQL",
            3389: "RDP", 5432: "PostgreSQL", 27017: "MongoDB"
        }
        return common_services.get(port, "Unknown")

    def grab_banner(self, sock: socket.socket) -> Optional[str]:
        """Attempt to grab service banner with multiple protocols."""
        try:
            # Try HTTP
            sock.send(b"GET / HTTP/1.1\r\nHost: " + self.target.encode() + b"\r\n\r\n")
            response = sock.recv(1024).decode(errors='ignore').strip()
            return response
        except:
            try:
                # Try simple connection banner
                return sock.recv(1024).decode(errors='ignore').strip()
            except:
                return None

    def check_common_vulnerabilities(self, port: int, banner: Optional[str]) -> List[str]:
        """Check for common vulnerabilities based on port and banner."""
        vulnerabilities = []

        if banner:
            # Check for version disclosure
            if any(x in banner.lower() for x in ['version', 'v1.', 'v2.']):
                vulnerabilities.append("Version disclosure in banner")

            # Check for default credentials
            if any(x in banner.lower() for x in ['default', 'admin', 'root']):
                vulnerabilities.append("Potential default credentials")

            # Check for common security misconfigurations
            if port == 21 and 'anonymous' in banner.lower():
                vulnerabilities.append("Anonymous FTP enabled")

        return vulnerabilities

    def generate_report(self) -> Dict:
        """Generate comprehensive scan report."""
        return {
            "scan_info": {
                "target": self.target,
                "port_range": self.port_range,
                "start_time": self.scan_start_time.isoformat(),
                "end_time": self.scan_end_time.isoformat(),
                "duration": (self.scan_end_time - self.scan_start_time).total_seconds()
            },
            "findings": self.results,
            "summary": {
                "total_open_ports": len(self.results),
                "vulnerable_services": len([r for r in self.results if r["vulnerabilities"]])
            }
        }

    def scan(self) -> Dict:
        """
        Execute the vulnerability scan.

        Returns:
            Dict: Scan report
        """
        if not self.validate_target():
            raise ValueError("Invalid target specified")

        self.scan_start_time = datetime.now()
        self.logger.info(f"Starting scan on {self.target}")

        # Using ThreadPoolExecutor for concurrent scanning
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.thread_count) as executor:
            executor.map(self.port_scan, range(self.port_range[0], self.port_range[1]))

        self.scan_end_time = datetime.now()
        self.logger.info(f"Scan completed on {self.target}")

        # Generate and save report
        report = self.generate_report()
        with open(f"scan_report_{self.target}_{self.scan_start_time.strftime('%Y%m%d_%H%M%S')}.json", 'w') as f:
            json.dump(report, f, indent=2)

        return report

def main():
    """Main function for command-line usage."""
    try:
        target = input("Enter target IP address or hostname: ")
        start_port = int(input("Enter start port (default 1): ") or 1)
        end_port = int(input("Enter end port (default 1024): ") or 1024)
        thread_count = int(input("Enter thread count (default 100): ") or 100)
        verbose = input("Enable verbose output? (y/n, default n): ").lower() == 'y'

        scanner = VulnerabilityScanner(
            target=target,
            port_range=(start_port, end_port),
            thread_count=thread_count,
            verbose=verbose
        )

        report = scanner.scan()
        print("\nScan Summary:")
        print(json.dumps(report["summary"], indent=2))
        print(f"\nDetailed report saved to: scan_report_{target}_{scanner.scan_start_time.strftime('%Y%m%d_%H%M%S')}.json")

    except KeyboardInterrupt:
        print("\nScan interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
